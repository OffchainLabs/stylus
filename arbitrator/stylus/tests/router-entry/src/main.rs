#![no_main]

use alloy_sol_types::{sol_data, Encodable, SolCall, SolType};
use hex;
use stylus_sdk::{
    alloy_primitives::{Address, U256},
    debug,
};

stylus_sdk::entrypoint!(user_main);

const SELECTOR_TRANSFER: u32 = 0x8a4068dd;
const SELECTOR_BALANCE_OF_SNAKE: u32 = 0x4668f7f4;
const SELECTOR_BALANCE_OF_CAMEL: u32 = 0x722713f7;
const SELECTOR_RETURN_ONE: u32 = 0x00000001;

trait ABIParam {
    type Sol: SolType;

    fn sol_type_name(&self) -> String {
        Self::Sol::sol_type_name().to_string()
    }
}

// TODO: Implement for all primitives and generalize for higher order types like structs
impl ABIParam for Address {
    type Sol = sol_data::Address;
}

impl ABIParam for U256 {
    type Sol = sol_data::Uint<256>;
}

// user defined handler
fn user_transfer(to: Address, amount: U256) {
    debug::println(format!("user_transfer({}, {})", to, amount));
}

// fn transfer(to: Address, amount: U256)
// sol signature: transfer(address,uint256)
// 4byte selector: 0x8a4068dd
// test params: recipient=0x... amount=69 -> bool=true
// note: this logic should be generated by a macro
fn transfer(input: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
    type UserParams = (Address, U256); // this would be extracted by macro
    type S1 = <Address as ABIParam>::Sol;
    type S2 = <U256 as ABIParam>::Sol;
    type SolParams = (S1, S2);

    // TODO: Generalize output
    type UserOut = ();
    type SolOut = ((),);

    debug::println(format!(
        "sig: transfer({},{})",
        S1::sol_type_name(),
        S2::sol_type_name(),
    ));

    let args = SolParams::decode(&input, true).unwrap();
    let output = user_transfer.apply(args);
    let response = SolOut::encode(&(output,));

    Ok(response)
}

// user defined handler
fn user_balance_of(account: Address) -> U256 {
    debug::println(format!("user_balance_of({})", account));
    U256::from(1_000)
}

// fn balance_of(account: Address) -> U256
// sol signature: balance_of(address), balanceOf(address)
// 4byte selectors: 0x4668f7f4, 0x722713f7
// test params: account=0x... -> 420 ether
// NOTE: This logic will be automatically generated by macro
fn balance_of(input: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
    type UserParams = (Address); // this would be extracted by macro
    type S1 = <Address as ABIParam>::Sol;
    type SolParams = (S1,);

    // TODO: Generalize output
    type UserOut = (U256,);
    type SolOut = (<U256 as ABIParam>::Sol,);

    debug::println(format!("sig: balance_of({})", S1::sol_type_name()));

    let args = SolParams::decode(&input, true).unwrap();
    let output = user_balance_of.apply(args);
    let response = SolOut::encode(&(output,));

    Ok(response)
}

// user defined handler that takes no params
fn user_return_one() -> U256 {
    debug::println(format!("user_return_one()"));
    U256::from(1)
}

// fn return_one() -> U256
// sol signature: return_one()
// 4byte selector: 0x000001
// NOTE: This logic will be automatically generated by macro
fn return_one(input: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
    type UserParams = ();
    type SolParams = ();

    // Todo: Generalize output
    type UserOut = (U256,);
    type SolOut = (<U256 as ABIParam>::Sol,);

    debug::println(format!("sig: return_one()"));

    let args = SolParams::decode(&input, true).unwrap();
    let output = user_return_one.apply(args);
    let response = SolOut::encode(&(output,));

    Ok(response)
}

trait Apply<Args> {
    type Output;
    fn apply(&self, args: Args) -> Self::Output;
}

macro_rules! impl_apply {
    // Empty case
    () => {};
    ($first_generic:ident $($other_generics:ident)*) => {
        impl_apply!($($other_generics)*);

        impl<$first_generic, $($other_generics,)* Ret, Func>
            Apply<($first_generic, $($other_generics,)*)>
            for Func
        where
            Func: Fn($first_generic, $($other_generics,)*) -> Ret,
        {
            type Output = Ret;
            #[allow(non_snake_case)]
            fn apply(
                &self,
                ($first_generic, $($other_generics,)*): ($first_generic, $($other_generics,)*),
            ) -> Self::Output {
                self($first_generic, $($other_generics,)*)
            }
        }
    };
}

impl<Ret, Func> Apply<()> for Func
where
    Func: Fn() -> Ret,
{
    type Output = Ret;
    fn apply(&self, (): ()) -> Self::Output {
        self()
    }
}

impl_apply!(A B C D E F G H I J K L M);

fn extract_call_parts(input: Vec<u8>) -> (u32, Vec<u8>) {
    let fn_selector: [u8; 4] = input[..4].try_into().unwrap();
    let fn_selector = u32::from_be_bytes(fn_selector);
    let args = input[4..].to_vec();
    (fn_selector, args)
}

fn user_main(input: Vec<u8>) -> Result<Vec<u8>, Vec<u8>> {
    let (fn_selector, args) = extract_call_parts(input);
    debug::println(format!("fn_selector: 0x{:08x}", fn_selector));

    // match branches to be generated
    let response = match fn_selector {
        SELECTOR_TRANSFER => transfer(args),
        SELECTOR_BALANCE_OF_SNAKE => balance_of(args),
        SELECTOR_BALANCE_OF_CAMEL => balance_of(args),
        SELECTOR_RETURN_ONE => return_one(args),
        _ => {
            debug::println("No func found for selector");
            Ok(vec![])
        }
    };

    response
}
